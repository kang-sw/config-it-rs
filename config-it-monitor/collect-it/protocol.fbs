
// Access level of individual client.
enum UsrAccessLv: byte {
    Rejected,
    Read,
    Write,
    Admin
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// 
// Registers a collector with the server.
// 
table ClRegisterInfo {
    // user defined name.
    name: string;
    
    // <pid>@<device_name>
    // 
    // If single application has multiple collectors, device_key would be same since they 
    // would share same pid. In this case, `name` should be different.
    app_key: string;
    
    // Description for this collector
    description: string;
    
    // The collector's epoch
    epoch_utc: ulong;
}

// Authentication information entity of collector. A client can access to the collector
// through data sink server, using this authentication information. 
//
// This request is issued from frontend's client, and routed to collector.
table ClAuthInfo {
    id: string;
    pw: string; // Hashed one.
    
    // This should be logged in the collector instance
    client_info: string;
}

// Reply for authentication request.
table ClAuthRep {
    // If `access_lv` is `UsrAccessLv::Rejected`, all other fileds remain invalid.
    access_lv: UsrAccessLv;
}

// Request to add a new user to the collector.
table ClAddAuth {
    // Unlike simple config edit operations, this request does not trust data-sink server's
    // authentication validation. Therefore, this request should be issued with admin 
    // athentication.
    admin_auth: ClAuthInfo;
    
    id: string;
    pw: string; // Hashed one.
    access_lv: UsrAccessLv;
}

// Request to remove a user from the collector. If all admin authentication is removed, 
// the fallback authentication that was hard-coded should be used. e.g. guest:guest
table ClDelAuth {
    admin_auth: ClAuthInfo;
    id: string;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// Represents single value payload of a property. Should be parsed as `msgpack` object.
table Value { msgpack: [ubyte]; }

//
// Synchronizes data-sink
//
// `SynNewTemplate + SynPropDef` -> `SynNewGroup` -> `SynPropUpdate`

table SynNewGroup {
    // Path to this group. Must be unique, 
    path: [string];
    template_key: string;
}

table SynRemoveGroup {
    path: [string];
}

table SynNewTemplate {
    template_key: string;
    defs: [SynPropDef];
}

table SynPropDef {
    def_id: long; // In practice, usually pointer address of metadata.
    
    name: string (required);
    description: string;
    source_pos: string;
    
    default: Value (required);
    min: Value;
    max: Value;
    one_of: [Value];
    
    no_export: bool;
    no_import: bool;
}

table SynPropUpdateArg {
    id: long;
    new_value: Value;
}


